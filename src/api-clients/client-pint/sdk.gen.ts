// This file is auto-generated by @hey-api/openapi-ts

import type { Options as ClientOptions, TDataShape, Client } from '@hey-api/client-fetch';
import type { GetHealthData, GetHealthResponse, GetApiFsEventsData, GetApiFsEventsResponse, GetApiFsStatsByPathData, GetApiFsStatsByPathResponse, GetApiFsStatsByPathError, DeleteApiFsFilesByPathData, DeleteApiFsFilesByPathResponse, DeleteApiFsFilesByPathError, GetApiFsFilesByPathData, GetApiFsFilesByPathResponse, GetApiFsFilesByPathError, PutApiFsFilesByPathData, PutApiFsFilesByPathResponse, PutApiFsFilesByPathError, DeleteApiDirectoriesByPathData, DeleteApiDirectoriesByPathResponse, DeleteApiDirectoriesByPathError, GetApiDirectoriesByPathData, GetApiDirectoriesByPathResponse, GetApiDirectoriesByPathError, PostApiDirectoriesByPathData, PostApiDirectoriesByPathResponse, PostApiDirectoriesByPathError, GetApiTerminalsData, GetApiTerminalsResponse, PostApiTerminalsData, PostApiTerminalsResponse, PostApiTerminalsError, DeleteApiTerminalsByIdData, DeleteApiTerminalsByIdResponse, DeleteApiTerminalsByIdError, GetApiTerminalsByIdData, GetApiTerminalsByIdResponse, GetApiTerminalsByIdError, GetApiTerminalsByIdStdoutData, GetApiTerminalsByIdStdoutResponse, GetApiTerminalsByIdStdoutError, GetApiTerminalsByIdStderrData, GetApiTerminalsByIdStderrResponse, GetApiTerminalsByIdStderrError, PostApiTerminalsByIdStdinData, PostApiTerminalsByIdStdinResponse, PostApiTerminalsByIdStdinError, GetApiTasksData, GetApiTasksResponse, GetApiTasksByIdData, GetApiTasksByIdResponse, GetApiTasksByIdError, PostApiTasksByIdRunData, PostApiTasksByIdRunResponse, PostApiTasksByIdRunError, PostApiTasksByIdStopData, PostApiTasksByIdStopResponse, PostApiTasksByIdStopError, PostApiTasksByIdRestartData, PostApiTasksByIdRestartResponse, PostApiTasksByIdRestartError, GetApiStateData, GetApiStateResponse, GetApiPortsData, GetApiPortsResponse } from './types.gen';
import { client as _heyApiClient } from './client.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = ClientOptions<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
};

/**
 * Health check endpoint
 * Returns the health status of the server
 */
export const getHealth = <ThrowOnError extends boolean = false>(options?: Options<GetHealthData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetHealthResponse, unknown, ThrowOnError>({
        url: '/health',
        ...options
    });
};

/**
 * Watch filesystem events
 * Watch filesystem changes matching a glob pattern. Use SSE for real-time events.
 */
export const getApiFsEvents = <ThrowOnError extends boolean = false>(options: Options<GetApiFsEventsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetApiFsEventsResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/fs/events',
        ...options
    });
};

/**
 * Get file or directory stats
 * Get filesystem statistics for a file or directory
 */
export const getApiFsStatsByPath = <ThrowOnError extends boolean = false>(options: Options<GetApiFsStatsByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetApiFsStatsByPathResponse, GetApiFsStatsByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/fs/stats/{path}',
        ...options
    });
};

/**
 * Delete file
 * Delete a file
 */
export const deleteApiFsFilesByPath = <ThrowOnError extends boolean = false>(options: Options<DeleteApiFsFilesByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteApiFsFilesByPathResponse, DeleteApiFsFilesByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/fs/files/{path}',
        ...options
    });
};

/**
 * Read file contents
 * Read file contents. Use SSE for chunked reading of large files.
 */
export const getApiFsFilesByPath = <ThrowOnError extends boolean = false>(options: Options<GetApiFsFilesByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetApiFsFilesByPathResponse, GetApiFsFilesByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/fs/files/{path}',
        ...options
    });
};

/**
 * Write to file
 * Write content to file or perform file operations
 */
export const putApiFsFilesByPath = <ThrowOnError extends boolean = false>(options: Options<PutApiFsFilesByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).put<PutApiFsFilesByPathResponse, PutApiFsFilesByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/fs/files/{path}',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete directory
 * Delete a directory and all its contents
 */
export const deleteApiDirectoriesByPath = <ThrowOnError extends boolean = false>(options: Options<DeleteApiDirectoriesByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteApiDirectoriesByPathResponse, DeleteApiDirectoriesByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/directories/{path}',
        ...options
    });
};

/**
 * List directory contents
 * List files and subdirectories in a directory
 */
export const getApiDirectoriesByPath = <ThrowOnError extends boolean = false>(options: Options<GetApiDirectoriesByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetApiDirectoriesByPathResponse, GetApiDirectoriesByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/directories/{path}',
        ...options
    });
};

/**
 * Create directory
 * Create a new directory
 */
export const postApiDirectoriesByPath = <ThrowOnError extends boolean = false>(options: Options<PostApiDirectoriesByPathData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostApiDirectoriesByPathResponse, PostApiDirectoriesByPathError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/directories/{path}',
        ...options
    });
};

/**
 * List terminals
 * Get list of all terminals. Use SSE for real-time updates.
 */
export const getApiTerminals = <ThrowOnError extends boolean = false>(options?: Options<GetApiTerminalsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetApiTerminalsResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/terminals',
        ...options
    });
};

/**
 * Create new terminal
 * Create a new terminal instance
 */
export const postApiTerminals = <ThrowOnError extends boolean = false>(options: Options<PostApiTerminalsData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostApiTerminalsResponse, PostApiTerminalsError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/terminals',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * Delete terminal
 * Delete a terminal and kill its process
 */
export const deleteApiTerminalsById = <ThrowOnError extends boolean = false>(options: Options<DeleteApiTerminalsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).delete<DeleteApiTerminalsByIdResponse, DeleteApiTerminalsByIdError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/terminals/{id}',
        ...options
    });
};

/**
 * Get terminal state
 * Get terminal information and state. Use SSE for real-time updates.
 */
export const getApiTerminalsById = <ThrowOnError extends boolean = false>(options: Options<GetApiTerminalsByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetApiTerminalsByIdResponse, GetApiTerminalsByIdError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/terminals/{id}',
        ...options
    });
};

/**
 * Get terminal stdout
 * Get terminal stdout output. Use SSE for real-time updates.
 */
export const getApiTerminalsByIdStdout = <ThrowOnError extends boolean = false>(options: Options<GetApiTerminalsByIdStdoutData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetApiTerminalsByIdStdoutResponse, GetApiTerminalsByIdStdoutError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/terminals/{id}/stdout',
        ...options
    });
};

/**
 * Get terminal stderr
 * Get terminal stderr output. Use SSE for real-time updates.
 */
export const getApiTerminalsByIdStderr = <ThrowOnError extends boolean = false>(options: Options<GetApiTerminalsByIdStderrData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetApiTerminalsByIdStderrResponse, GetApiTerminalsByIdStderrError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/terminals/{id}/stderr',
        ...options
    });
};

/**
 * Send input to terminal
 * Send input to terminal stdin
 */
export const postApiTerminalsByIdStdin = <ThrowOnError extends boolean = false>(options: Options<PostApiTerminalsByIdStdinData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostApiTerminalsByIdStdinResponse, PostApiTerminalsByIdStdinError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/terminals/{id}/stdin',
        ...options,
        headers: {
            'Content-Type': 'application/json',
            ...options?.headers
        }
    });
};

/**
 * List tasks
 * Get list of all tasks. Use SSE for real-time updates.
 */
export const getApiTasks = <ThrowOnError extends boolean = false>(options?: Options<GetApiTasksData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetApiTasksResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/tasks',
        ...options
    });
};

/**
 * Get task state
 * Get task information and state. Use SSE for real-time updates.
 */
export const getApiTasksById = <ThrowOnError extends boolean = false>(options: Options<GetApiTasksByIdData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).get<GetApiTasksByIdResponse, GetApiTasksByIdError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/tasks/{id}',
        ...options
    });
};

/**
 * Run task
 * Start executing a task
 */
export const postApiTasksByIdRun = <ThrowOnError extends boolean = false>(options: Options<PostApiTasksByIdRunData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostApiTasksByIdRunResponse, PostApiTasksByIdRunError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/tasks/{id}/run',
        ...options
    });
};

/**
 * Stop task
 * Stop a running task
 */
export const postApiTasksByIdStop = <ThrowOnError extends boolean = false>(options: Options<PostApiTasksByIdStopData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostApiTasksByIdStopResponse, PostApiTasksByIdStopError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/tasks/{id}/stop',
        ...options
    });
};

/**
 * Restart task
 * Restart a task (stop if running, then start)
 */
export const postApiTasksByIdRestart = <ThrowOnError extends boolean = false>(options: Options<PostApiTasksByIdRestartData, ThrowOnError>) => {
    return (options.client ?? _heyApiClient).post<PostApiTasksByIdRestartResponse, PostApiTasksByIdRestartError, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/tasks/{id}/restart',
        ...options
    });
};

/**
 * Get sandbox state
 * Get the current state of the sandbox including version and setup status
 */
export const getApiState = <ThrowOnError extends boolean = false>(options?: Options<GetApiStateData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetApiStateResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/state',
        ...options
    });
};

/**
 * List open ports
 * Get list of open ports. Use SSE for real-time updates.
 */
export const getApiPorts = <ThrowOnError extends boolean = false>(options?: Options<GetApiPortsData, ThrowOnError>) => {
    return (options?.client ?? _heyApiClient).get<GetApiPortsResponse, unknown, ThrowOnError>({
        security: [
            {
                scheme: 'bearer',
                type: 'http'
            },
            {
                name: 'Authorization',
                type: 'apiKey'
            },
            {
                in: 'query',
                name: 'token',
                type: 'apiKey'
            }
        ],
        url: '/api/ports',
        ...options
    });
};